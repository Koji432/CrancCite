<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>リンク機構 体験サイト - スマホ最適化</title>
    <style>
        body {
            font-family: 'Hiragino Sans', 'Meiryo', sans-serif;
            text-align: center;
            background-color: #f4f4f9;
            padding: 5px; /* パディングを減らして画面を広く使う */
        }
        h1 {
            color: #0056b3;
            margin: 10px 0 5px 0;
            font-size: 1.5em; /* フォントサイズ調整 */
        }
        h2 {
            color: #1d3557;
            margin-top: 25px; /* マージンを調整 */
            font-size: 1.2em; /* フォントサイズ調整 */
        }
        canvas {
            border: 3px solid #333;
            background-color: #fff;
            display: block;
            /* width/heightはJavaScriptで設定するが、ここではmax-widthを設定 */
            max-width: 100%; 
            height: auto;
            margin: 10px auto;
            cursor: grab;
            touch-action: none; /* スマホでスクロールと間違われないようにする */
        }
        canvas:active {
            cursor: grabbing;
        }
        .instruction {
            margin-top: 5px;
            color: #e63946;
            font-weight: bold;
            font-size: 1.1em; /* タップ指示のフォントを大きく */
        }
        .mechanism-container {
            margin-bottom: 25px;
        }
        .info {
            font-size: 0.85em; /* infoのフォントサイズ調整 */
            margin-top: 10px;
            padding: 5px;
        }
        .controls button {
            padding: 8px 15px;
            margin: 5px;
            background-color: #2a9d8f;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9em;
        }
        .controls button:hover {
            background-color: #264653;
        }
    </style>
</head>
<body>

    <h1>動かしてみよう リンク機構！！</h1>
    <p class="instruction">黄色い点をタップして動かしてね！</p>

    <div class="mechanism-container">
        <h2>平行クランク</h2>
        <canvas id="fourBarCanvas" width="600" height="350"></canvas>
        <div id="fourBarInfo" class="info"></div>
        <div class="controls">
            <button onclick="clearTrace('fourBar')">軌跡をリセット</button>
        </div>
    </div>

    <div class="mechanism-container">
        <h2>往復直線スライダクランク機構</h2>
        <canvas id="sliderCrankCanvas" width="600" height="350"></canvas>
        <div id="sliderCrankInfo" class="info"></div>
        <div class="controls">
            <button onclick="clearTrace('sliderCrank')">軌跡をリセット</button>
        </div>
    </div>


    <script>
        const TWO_PI = 2 * Math.PI;

        //==================================================
        // 軌跡データ (スライダクランク機構にB点用の軌跡を追加)
        //==================================================
        let fourBarTrace = [];      // C点の軌跡を保存
        let sliderCrankTraceA = []; // A点の軌跡を保存 (クランク先端)
        let sliderCrankTraceB = []; // B点の軌跡を保存 (スライダ先端)

        // 軌跡をクリアするグローバル関数（HTMLボタン用）
        function clearTrace(mechanism) {
            if (mechanism === 'fourBar') {
                fourBarTrace = [];
                drawFourBar();
            } else if (mechanism === 'sliderCrank') {
                sliderCrankTraceA = [];
                sliderCrankTraceB = []; // B点の軌跡もリセット
                drawSliderCrank();
            }
        }

        // 補助関数: 軌跡の描画
        function drawTrace(ctx, traceArray, color) {
            if (traceArray.length < 2) return;

            ctx.beginPath();
            ctx.strokeStyle = color;
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.5; 
            
            ctx.moveTo(traceArray[0].x, traceArray[0].y);
            for (let i = 1; i < traceArray.length; i++) {
                ctx.lineTo(traceArray[i].x, traceArray[i].y);
            }
            ctx.stroke();
            ctx.globalAlpha = 1.0; 
        }

        //==================================================
        // 補助関数: 描画ヘルパー
        //==================================================

        function drawLink(ctx, x1, y1, x2, y2, color, label) {
            ctx.strokeStyle = color;
            ctx.lineWidth = 8;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(x1, y1);
            ctx.lineTo(x2, y2);
            ctx.stroke();
            
            ctx.fillStyle = '#333';
            ctx.font = '12px sans-serif';
            ctx.fillText(label, (x1 + x2) / 2 + 5, (y1 + y2) / 2 + 5);
        }

        function drawPin(ctx, x, y, color) {
            const pinRadius = 8;
            ctx.beginPath();
            ctx.arc(x, y, pinRadius, 0, TWO_PI);
            ctx.fillStyle = color;
            ctx.fill();
            ctx.lineWidth = 1;
            ctx.strokeStyle = '#333';
            ctx.stroke();
        }

        //==================================================
        // 1. 四節リンク機構のロジック (平行クランク動作に修正)
        //==================================================
        
        const fourBarCanvas = document.getElementById('fourBarCanvas');
        const fourBarCtx = fourBarCanvas.getContext('2d');
        const fourBarW = fourBarCanvas.width;
        const fourBarH = fourBarCanvas.height;
        const fourBarInfo = document.getElementById('fourBarInfo');

        // ★ 平行クランクになるようリンク長を修正
        const FB_L1 = 200; // 固定リンク
        const FB_L2 = 80;  // 原動節
        const FB_L3 = 200; // 連結節 (固定リンクと等しい)
        const FB_L4 = 80;  // 従動節 (原動節と等しい)
        
        let fourBarAngle = Math.PI / 4; 

        const FB_centerX = fourBarW / 2;
        const FB_centerY = fourBarH / 2 + 50;

        const FB_Ax = FB_centerX - FB_L1 / 2;
        const FB_Ay = FB_centerY;
        const FB_Dx = FB_centerX + FB_L1 / 2;
        const FB_Dy = FB_centerY;

        function checkGrashof() {
            fourBarInfo.innerHTML = `
                <div style="color: green; font-weight: bold; font-size: 1.1em;">
                    平行クランク機構
                </div>
                <div>
                    L1=${FB_L1}, L2=${FB_L2}, L3=${FB_L3}, L4=${FB_L4}
                    (L1=L3, L2=L4)
                </div>
            `;
        }

        function drawFourBar() {
            const Bx = FB_Ax + FB_L2 * Math.cos(fourBarAngle);
            const By = FB_Ay + FB_L2 * Math.sin(fourBarAngle);

            const Kx = FB_Dx - Bx;
            const Ky = FB_Dy - By;
            const K = Math.sqrt(Kx * Kx + Ky * Ky);
            
            if (K > FB_L3 + FB_L4 || K < Math.abs(FB_L3 - FB_L4)) {
                fourBarCtx.clearRect(0, 0, fourBarW, fourBarH);
                fourBarCtx.fillStyle = 'red';
                fourBarCtx.fillText('リンクの長さが不適切です。', FB_centerX - 100, FB_centerY);
                return; 
            }

            // 平行クランクの計算 (ここでは通常の四節リンクの計算を適用)
            const beta = Math.acos((FB_L4 * FB_L4 + K * K - FB_L3 * FB_L3) / (2 * FB_L4 * K));
            const gamma = Math.atan2(Ky, Kx);
            
            const theta4 = gamma - beta; // 通常は下の構成
            const Cx = FB_Dx - FB_L4 * Math.cos(theta4);
            const Cy = FB_Dy - FB_L4 * Math.sin(theta4);

            fourBarCtx.clearRect(0, 0, fourBarW, fourBarH);
            
            // 軌跡の描画 (C点)
            drawTrace(fourBarCtx, fourBarTrace, '#f4a261'); 

            // リンクの描画
            drawLink(fourBarCtx, FB_Ax, FB_Ay, Bx, By, '#e63946', `L2`);
            drawLink(fourBarCtx, Bx, By, Cx, Cy, '#457b9d', `L3`);
            drawLink(fourBarCtx, FB_Dx, FB_Dy, Cx, Cy, '#f4a261', `L4`);
            
            fourBarCtx.strokeStyle = '#333';
            fourBarCtx.lineWidth = 15;
            fourBarCtx.beginPath();
            fourBarCtx.moveTo(FB_Ax, FB_Ay);
            fourBarCtx.lineTo(FB_Dx, FB_Dy);
            fourBarCtx.stroke();

            // ピンの描画
            drawPin(fourBarCtx, FB_Ax, FB_Ay, '#2a9d8f');
            drawPin(fourBarCtx, FB_Dx, FB_Dy, '#2a9d8f');
            drawPin(fourBarCtx, Bx, By, '#e9c46a');
            drawPin(fourBarCtx, Cx, Cy, '#a8dadc');
            
            // 軌跡座標の保存（C点）
            fourBarTrace.push({x: Cx, y: Cy});
            if (fourBarTrace.length > 500) { 
                fourBarTrace.shift();
            }
        }

        //==================================================
        // 2. スライダクランク機構のロジック (2つの軌跡を復活)
        //==================================================

        const sliderCrankCanvas = document.getElementById('sliderCrankCanvas');
        const sliderCrankCtx = sliderCrankCanvas.getContext('2d');
        const sliderCrankW = sliderCrankCanvas.width;
        const sliderCrankH = sliderCrankCanvas.height;
        const sliderCrankInfo = document.getElementById('sliderCrankInfo');

        const SC_R = 70;  
        const SC_L = 200; 
        
        let sliderCrankAngle = Math.PI / 4; 

        const SC_Ox = sliderCrankW / 2 - 100; 
        const SC_Oy = sliderCrankH / 2;
        
        sliderCrankInfo.innerHTML = `
            <div style="color: green; font-weight: bold; font-size: 1.1em;">
                円運動 → 直線運動 (往復)
            </div>
            <div id="SC_displacement">変位: --</div>
        `;


        function drawSliderCrank() {
            const Ax = SC_Ox + SC_R * Math.cos(sliderCrankAngle);
            const Ay = SC_Oy + SC_R * Math.sin(sliderCrankAngle);

            const sin_theta_sq = Math.pow(SC_R * Math.sin(sliderCrankAngle), 2);
            
            if (SC_L * SC_L < sin_theta_sq) {
                sliderCrankCtx.clearRect(0, 0, sliderCrankW, sliderCrankH);
                sliderCrankCtx.fillStyle = 'red';
                sliderCrankCtx.fillText('計算エラー', sliderCrankW/2, sliderCrankH/2);
                return; 
            }
            
            const Bx = Ax + Math.sqrt(SC_L * SC_L - sin_theta_sq);
            const By = SC_Oy; 

            sliderCrankCtx.clearRect(0, 0, sliderCrankW, sliderCrankH);
            
            // ★ 軌跡の描画 (A点: 円)
            drawTrace(sliderCrankCtx, sliderCrankTraceA, '#e63946');
            
            // ★ 軌跡の描画 (B点: 水平直線)
            drawTrace(sliderCrankCtx, sliderCrankTraceB, '#f4a261'); 

            // レールの描画
            sliderCrankCtx.strokeStyle = '#999';
            sliderCrankCtx.lineWidth = 10;
            sliderCrankCtx.beginPath();
            sliderCrankCtx.moveTo(0, SC_Oy);
            sliderCrankCtx.lineTo(sliderCrankW, SC_Oy);
            sliderCrankCtx.stroke();
            
            // リンクの描画
            drawLink(sliderCrankCtx, SC_Ox, SC_Oy, Ax, Ay, '#e63946', `R`);
            drawLink(sliderCrankCtx, Ax, Ay, Bx, By, '#457b9d', `L`);

            // スライダ (B) の描画
            const sliderW = 30;
            const sliderH = 50;
            sliderCrankCtx.fillStyle = '#f4a261'; 
            sliderCrankCtx.fillRect(Bx - sliderW / 2, By - sliderH / 2, sliderW, sliderH);
            
            // ピンの描画
            drawPin(sliderCrankCtx, SC_Ox, SC_Oy, '#2a9d8f');
            drawPin(sliderCrankCtx, Ax, Ay, '#e9c46a');
            drawPin(sliderCrankCtx, Bx, By, '#a8dadc');

            // ★ 軌跡座標の保存
            sliderCrankTraceA.push({x: Ax, y: Ay});
            sliderCrankTraceB.push({x: Bx, y: By}); 
            
            if (sliderCrankTraceA.length > 500) { 
                sliderCrankTraceA.shift();
                sliderCrankTraceB.shift(); 
            }

            const displacement = Bx - (SC_Ox + SC_R);
            document.getElementById('SC_displacement').textContent = `スライダ位置(X): ${Bx.toFixed(2)}`;
        }


        //==================================================
        // 共通: ドラッグ操作のロジック (タッチ対応は元からOK)
        //==================================================

        let isDragging = false;
        let activeCanvasId = null; 
        const dragRadius = 15; 

        function getCanvasMousePos(canvas, event) {
            const rect = canvas.getBoundingClientRect();
            // ★ スマホ対応: event.touches[0]でタッチ座標を取得
            const clientX = event.touches ? event.touches[0].clientX : event.clientX;
            const clientY = event.touches ? event.touches[0].clientY : event.clientY;

            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        function handleDragStart(event) {
            event.preventDefault(); 
            const canvas = event.target;
            const pos = getCanvasMousePos(canvas, event);
            activeCanvasId = canvas.id;

            let fixedX, fixedY, linkLength;
            let currentAngle;

            if (activeCanvasId === 'fourBarCanvas') {
                fixedX = FB_Ax; fixedY = FB_Ay; linkLength = FB_L2;
                currentAngle = fourBarAngle;
            } else if (activeCanvasId === 'sliderCrankCanvas') {
                fixedX = SC_Ox; fixedY = SC_Oy; linkLength = SC_R;
                currentAngle = sliderCrankAngle;
            } else {
                return;
            }

            // ドラッグ開始を判定する範囲を広く設定 (タッチしやすいように)
            const targetX = fixedX + linkLength * Math.cos(currentAngle);
            const targetY = fixedY + linkLength * Math.sin(currentAngle);

            // ★ ドラッグ可能エリアを広げる (ピンの半径*4 だったのを、今回はピンの半径*8)
            const touchRadius = 8;
            const distSq = (pos.x - targetX) ** 2 + (pos.y - targetY) ** 2;
            if (distSq < touchRadius * touchRadius * 8) { 
                isDragging = true;
            }
        }

        function handleDragMove(event) {
            if (!isDragging || !activeCanvasId) return;
            event.preventDefault();
            
            const canvas = document.getElementById(activeCanvasId);
            const pos = getCanvasMousePos(canvas, event);

            let fixedX, fixedY;

            if (activeCanvasId === 'fourBarCanvas') {
                fixedX = FB_Ax; fixedY = FB_Ay;
                const dx = pos.x - fixedX;
                const dy = pos.y - fixedY;
                fourBarAngle = Math.atan2(dy, dx);
                drawFourBar();
            } else if (activeCanvasId === 'sliderCrankCanvas') {
                fixedX = SC_Ox; fixedY = SC_Oy;
                const dx = pos.x - fixedX;
                const dy = pos.y - fixedY;
                sliderCrankAngle = Math.atan2(dy, dx);
                drawSliderCrank();
            }
        }

        function handleDragEnd() {
            isDragging = false;
            activeCanvasId = null;
        }

        // イベントリスナーの追加 (touchstart/touchmove/touchendは既に含まれており、適切に動作します)
        [fourBarCanvas, sliderCrankCanvas].forEach(canvas => {
            canvas.addEventListener('mousedown', handleDragStart);
            canvas.addEventListener('mousemove', handleDragMove);
            canvas.addEventListener('mouseup', handleDragEnd);
            canvas.addEventListener('mouseleave', handleDragEnd);

            canvas.addEventListener('touchstart', handleDragStart);
            canvas.addEventListener('touchmove', handleDragMove);
            canvas.addEventListener('touchend', handleDragEnd);
            canvas.addEventListener('touchcancel', handleDragEnd);
        });

        // 初期化処理
        window.onload = () => {
            // キャンバスサイズをレスポンシブにする (スマホ向け)
            [fourBarCanvas, sliderCrankCanvas].forEach(canvas => {
                const containerWidth = canvas.parentElement.clientWidth;
                // PCでの理想的なサイズ(600)と、現在のコンテナ幅の小さい方を選ぶ
                const canvasSize = Math.min(600, containerWidth - 20); 
                canvas.width = canvasSize;
                canvas.height = canvasSize * 0.58; // 600x350の比率を維持
            });

            checkGrashof(); 
            drawFourBar(); 
            drawSliderCrank();
        };
    </script>
</body>
</html>
